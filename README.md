In JavaScript, `var`, `let`, and `const` are all ways to create variables, but they don’t behave the same way. Think of `var` as the old, less strict version it’s function-scoped, which means even if you declare it inside a block like an `if` statement, it can still be accessed outside of that block. This sometimes leads to confusing bugs, and it also allows you to redeclare the same variable name without any error. On the other hand, `let` and `const` are newer and safer. They are block-scoped, meaning they only exist inside the curly braces `{}` where they are defined. With `let`, you can change the value later, but you can’t declare the same variable again in the same scope. `const` is even stricter once you assign a value to it, you can’t reassign it. Because of this, developers usually prefer `let` and `const` in modern JavaScript since they make the code more predictable and easier to manage.

In JavaScript, `map()`, `forEach()`, and `filter()` are all used to loop through arrays, but they are used for different purposes. `forEach()` is simply used to run a function on every element in an array, but it does not return a new array it’s mainly used when you just want to perform an action, like printing values or updating something outside the array. On the other hand, `map()` creates and returns a new array by transforming each element of the original array. It keeps the same length but changes the values based on what you return inside it. `filter()` is different because it also returns a new array, but it only includes the elements that pass a certain condition, so the new array can be shorter than the original one. In short, use `forEach()` when you just want to do something with each item, `map()` when you want to transform every item, and `filter()` when you want to select specific items based on a condition.


Arrow functions are a shorter and cleaner way to write functions in JavaScript, introduced in ES6. Instead of using the traditional `function` keyword, arrow functions use the `=>` syntax, which makes the code more compact and easier to read, especially for small functions. For example, instead of writing `function add(a, b) { return a + b; }`, you can write `const add = (a, b) => a + b;`. One of the biggest differences is how they handle `this`. Arrow functions do not have their own `this` value; instead, they inherit `this` from the surrounding scope. This makes them very useful inside objects or callbacks where regular functions might lose the correct `this` reference. Because of their simplicity and predictable behavior with `this`, arrow functions are commonly used in modern JavaScript, especially with array methods like `map()`, `filter()`, and `forEach()`.


Destructuring assignment in ES6 is a cleaner way to pull values out of arrays or objects and store them in variables. Instead of accessing each value one by one, you can “unpack” them in a single line. For example, with an array like `const numbers = [10, 20, 30];`, you can write `const [a, b, c] = numbers;` and now `a`, `b`, and `c` automatically hold those values.
It works similarly with objects, but instead of position, it matches by property name. So if you have `const user = { name: "Pritom", age: 20 };`, you can write `const { name, age } = user;` and directly get those properties into variables. You can even rename them or set default values if needed.
Overall, destructuring just makes your code shorter, clearer, and easier to read, especially when working with arrays, objects, or function parameters in modern JavaScript.


Template literals in ES6 are a modern and more flexible way to work with strings in JavaScript. Instead of using single (`' '`) or double (`" "`) quotes, template literals use backticks (`` ` ` ``). The biggest advantage is that they allow you to easily insert variables or expressions directly inside a string using `${}`. For example, instead of writing `"Hello " + name + "!"`, you can write `` `Hello ${name}!` ``, which is cleaner and easier to read.
Another major difference is that template literals support multi-line strings without needing special characters like `\n`. You can simply press Enter inside the backticks, and the formatting will be preserved. They also allow you to embed expressions, like calculations or function calls, inside `${}`.
Compared to traditional string concatenation (using `+`), template literals make the code more readable, less messy, and easier to maintain—especially when building longer or more dynamic strings.
